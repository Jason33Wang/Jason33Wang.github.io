<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django笔记1]]></title>
    <url>%2F2020%2F01%2F16%2FDjango%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1 day了解小知识 了解 djngo设计模式（MVC，MTV） 安装django（1.11.4） pip install Django==1.11.4 创建项目 在合适位置创建一个目录 /home/jason/Doucements/code/forDjango/ 在目录位置打开终端 django-admin startproject project01 tree . /F manage.py 是一个命令行工具，可以使我们用多种方式对django项目进行交互 init.py 项目的配置文件 urls.py 项目的url声明 wsgi.py 项目与wsgi兼容的web服务入口 基本操作设计表结构 班级表结构 表名 grade 字段 班级名称 gname 成立时间gdate 女生总数ggirlname 男生总数gboyname 是否删除isDelete 学生表结构 表名student 字段 学生姓名sname 学生性别sgender 学生年龄sage 学生简介scontend 学生班级sgrade 是否删除isDelete 配置数据库 （注意django 默认sqlite） 在setting.py文件中的databasees选项中进行数据库配置 配置mysql python3 安装的pymysql 在 init文件中 写入下面两行代码 12import pymysqlpymysql.install_as_MySQLdb() 创建一个数据库 配置 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'forDjango', 'USER': 'root', 'PASSWORD': 'qq123', 'HOST': 'localhost', 'PORT': '3306', &#125;&#125; 创建应用 在一个项目中可以创建多个应用，每个应用进行一种业务处理 打开终端，进入project01目录 python manage.py startapp myApp myApp目录说明 admin.py 站点配置 model.py 模型 view.py 视图 激活应用 在setting.py文件中，将myApp应用加入到INSTALLED_APP中 123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myAPP',] 定义模型 一个数据表就对应一个模型 在models.py中定义模型 引入from django.db import models 模型类型要继承models.Model类 123456789101112131415161718from django.db import models# Create your models here.class Grades(models.Model): gname = models.CharField(max_length=20) gdate = models.DateField() ggirlnum = models.IntegerField() gboynum = models.IntegerField() isDelete = models.BooleanField(default=False)class Students(models.Model): sname = models.CharField(max_length=20) sgender = models.BooleanField(default=True) sage = models.IntegerField() scontend = models.CharField(max_length=20) isDelete = models.BooleanField(default=False) sgrade = models.ForeignKey("Grades") 说明： 不需要定义主键， 在生成时自动添加，并且值为自动增加 在数据库中生成数据表 生成迁移文件 python manage.py makemigrations 在migration目录下生成了以迁移文件，此时数据库中还有生成数据表 执行迁移（相当于执行了sql语句） python manage.py migrate 数据表已经生成， 测试数据操作 进入到python mange.py shell 引入包 1234from myApp.models import Grades,Studentsfrom django.utils improt timezonefrom datetime import *Grades.objects.all() # 类名.object.all()查询该表所有数据 添加数据 本质：创建一个模型的实例 1234567grade1=Grade()grade1.gname ='python04'grade1.gdate=datetime(year=2017,month=7,day=17)grade1.ggirlnum=2grade1.gboynum=70###关键步骤,执行save后才能像数据库汇总存储数据grade1.save() 为了方便查看数据可以mdoel.py中Grade类中重写__str__函数 12def __str__(self): return "%s-%d-%d" %(self.gname, self.ggirlnum, self.gboynum) 查看某个对象 12Grade.objects.get(pk=2)#类名.objects.get(pk=2) 修改数据 12对象名.属性=新值对象名.save() 删除数据 1对象名.delete() 关联对象 1234567stu = Student()stu.sname="jason"stu.sgender=Truestu.sage=22stu.scontend='i am jason'stu.sgrade = garade1 #关联数据库，生成外键stu.save() 获得关联对象的集合 需求：获取pyhton04班级的所有学生 对象名关联的类名小写_set.all() grade1.students_set.all() 创建关联对象 12stu = grade1.students_set.create(sname=u'曾志伟'，sgender=True,scontend=u'我叫曾志伟'，sage=45)#不需要save（） 启动服务器 格式 python manage.py runserver ip:port ip 可以不写，表示本机ip 端口号默认是8000 这是一个pyhton写的轻量级web服务器，仅用来在开发测试中使用 Admin站点管理 概述 内容发布：负责添加、修改、删除内容 公共访问 配置Admin应用 在settings.py文件中的INSTALLED_APPS中添加‘django.contrib.admin’默认已经添加好了 创建管理员用户 python manage.py createsuperuser 依次输入用户信息 可以在127.0.0.1:8000/admin/网址进入管理员登录界面 汉化 修改setting.py文件中的language选项为zh-Hans，还有TIME_ZONE=’Asia/Shanghai‘ 管理数据表 修改myApp目录下的admin.py文件 123from .models import Grades,Studentsadmin.site.register(Grades)admin.site.register(Students) 自定义管理页面 12345678910111213141516171819202122class GradeAdmin(admin.ModelAdmin): # 列表页属性 #显示字段 list_display = ['pk','gname','gdate','ggirlnum','gboynum','isDelete'] #过滤字段 list_filter = ['gname'] #搜索字段 search_fields = ['gname'] #分页 list_per_page = 5 # 添加、修改页属性 #规定属性的顺序 # 给属性分组 #fieldsets和field不能同时使用 #fields = fieldsets = [ ("num",&#123;"fields":['ggirlnum','gboynum']&#125;), ("base",&#123;"fields":['gname','gdate','isDelete']&#125;), ]#注意：自定义完成已定义要注册admin.site.register(Grades,GradeAdmin)admin.site.register(Students) 关联对象 需求：在创建一个班级时可以直接添加几个学生 12345class StudentInfo(admin.TabularInline): #还有一个StackedInline model = Students extra =2class GradeAdmin(admin.ModelAdmin): inlines = [StudentInfo] 布尔值显示问题 12345678class StudentsAdmin(admin.ModelAdmin): def gender(self): if self.sgender: return "男" else: return "女" #设置页面列的名称 gender.short_description = "性别" 执行动作在页面位置问题 12actions_on_top = Falseactions_on_bottom = True 使用装饰器来进行注册 1@admin.register(类名) 视图的基本使用 在django中，视图对web请求进行回应 视图就是python函数，在view.py文件中定义 定义视图123from django.http import HttpResponsedef index(request): return HttpResponse("jason is a good man") 配置URL控制器 修改project目录下的urls.py文件 1234567from django.conf.urls import url,includefrom django.contrib import adminurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^', include('myApp.urls')),] 在myApp应用目录下创建一个urls.py文件 12345from django.conf.urls import urlfrom . import viewsurlpatterns=[ url(r'^$',views.index)] 模板的基本使用 模板是HTML页面，可以根据视图中传递过来的数据进行填充 创建模板 创建templates目录，在目录下创建对应项目的模板目录（project/templates/myApp） 配置模板路径 修改setting.py文件下的templates 12345678910111213141516TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', #设置下面的DIRS属性 'DIRS': [os.path.join(BASE_DIR,'templates')], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 定义两个模板 在templates/myApp/目录下定义两个模板（grades.html文件和students.html） 模板语法 12&#123;&#123;输出值，可以是变量，也可以是对象属性&#125;&#125;&#123;&#123;%执行代码段%&#125;&#125; http://127.0.0.1:8000/grades/ 写grades.html模板 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;班级信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;班级信息列表&lt;/h1&gt;&lt;ul&gt; &lt;!--[python04, python05,python06]--&gt; &#123;%for grade in grades%&#125; &lt;li&gt; &lt;a href="#"&gt;&#123;&#123;grade.gname&#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;%endfor%&#125;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 去视图中写函数，用来响应http请求即调用模板 12345def grades(request): #去模板中取数据 gradesList = Grades.objects.all() #将数据传递给模板，模板在渲染页面，将渲染好的页面返回浏览器 return render(request,'myApp/grades.html',&#123;"grades":gradesList&#125;) 要去myAPP中的urls.py 加入模板 1234urlpatterns=[ url(r'^$',views.index), url(r'^grades/$',views.grades)] 点击班级，显示对应班级的所有学生 修改模板 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;班级信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;班级信息列表&lt;/h1&gt;&lt;ul&gt; &lt;!--[python04, python05,python06]--&gt; &#123;%for grade in grades%&#125; &lt;li&gt; &lt;!--主要是加入了href，--&gt; &lt;a href="&#123;&#123;grade.id&#125;&#125;"&gt;&#123;&#123;grade.gname&#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;%endfor%&#125;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 定义视图 123456789101112131415161718192021222324from django.shortcuts import render# Create your views here.from django.http import HttpResponsefrom .models import Grades,Studentsdef index(request): return HttpResponse("jason is a good man")def detail(request,num,num2): return HttpResponse("detail-%s-%s" %(num,num2))def grades(request): #去模板中取数据 gradesList = Grades.objects.all() #将数据传递给模板，模板在渲染页面，将渲染好的页面返回浏览器 return render(request,'myApp/grades.html', &#123;"grades":gradesList&#125;)def students(request): studentsLsit = Students.objects.all() return render(request,'myApp/students.html',&#123;"students":studentsLsit&#125;)def gradestudents(request,num): grade = Grades.objects.get(pk=num) studentsLsit = grade.students_set.all() return render(request, 'myApp/students.html', &#123;"students": studentsLsit&#125;) 配置url 12345678from django.conf.urls import urlfrom . import viewsurlpatterns=[ url(r'^$',views.index), url(r'^grades/$',views.grades), url(r'^students/$',views.students), url(r'^grades/(\d+)$',views.gradestudents)]]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用keras搭建DQN]]></title>
    <url>%2F2018%2F09%2F14%2F%E7%94%A8keras%E6%90%AD%E5%BB%BADQN%2F</url>
    <content type="text"><![CDATA[dqn总结：最近时间虽然一直看这个dqn代码，虽然看懂了，但是思路却一直不明确，无法自己复写出自己的代码，所以就想写一篇博客来整理一下思路。如果这篇文章写完了，应该思路就清晰了。 本文主要是看了莫烦的教学视频，在视频中，老师（尊称一声老师O(∩_∩)O哈哈~）是用tensoflow1.2来搭建框架的。本人在看懂了代码后，认为DQN中采用了两个模型，此时用tensorflow来完成这些网络的灵活搭建时当让是最好的选择，但是在我看来，似乎keras中的函数式模型似乎也可以做到啊（Sequential模型肯定是不能完成这件事的），所以我就想用keras来重写这个代码，以此来验证自己是不是真的把DQN的实现过程搞懂了。 1234567891011121314#首先我们要构建一个DQN类class DQN: #之后我们需要构建网络 def _build_net(self): pass #学习需要经验池，这个学习是off-learning def store_transition(self,s,a,r,s_): pass #进行学习 def learn(self): pass #动作决策 def choose_action(self,observation): pass 以上就是我们要完成的东西了，按四个部分一次完成就可以实现DQN类了 但是我们还要重写类方法中__init__方法： 1234567891011121314151617181920212223242526def __init__( self, n_actions, n_features, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9, replace_target_iter=300, memory_size=500, batch_size=32, e_greedy_increment=None, output_graph=False,): self.n_actions = n_actions self.n_features = n_features self.lr = learning_rate self.gamma = reward_decay self.epsilon_max = e_greedy self.replace_target_iter = replace_target_iter self.memory_size = memory_size self.batch_size = batch_size self.epsilon_increment = e_greedy_increment self.epsilon = 0 if e_greedy_increment is not None else self.epsilon_max self.learn_step_counter = 0 self.memory = np.zeros((self.memory_size, n_features * 2 + 2)) self._build_net() 其实用keras来实现DQN的话，和tenosrflow来写，没有很大的区别。主要是就是在构建网络时代码有些许差别。代码如下： 1234567891011121314151617def _build_net(self): # 构建evaluation网络 eval_inputs = Input(shape=(self.n_features,)) x = Dense(64, activation='relu')(eval_inputs) x = Dense(64, activation='relu')(x) self.q_eval = Dense(self.n_actions)(x) # 构建target网络，注意这个target层输出是q_next而不是，算法中的q_target target_inputs = Input(shape=(self.n_features,)) x = Dense(64, activation='relu')(target_inputs) x = Dense(64, activation='relu')(x) self.q_next = Dense(self.n_actions)(x) self.model1 = Model(target_inputs, self.q_next) self.model2 = Model(eval_inputs, self.q_eval) rmsprop = RMSprop(lr=self.lr) self.model1.compile(loss='mean_squared_error', optimizer=rmsprop, metrics=['accuracy']) self.model2.compile(loss='mean_squared_error', optimizer=rmsprop, metrics=['accuracy']) 每隔一段时间将evaluation层参数赋值给target层 1234567def store_transition(self, s, a, r, s_): if not hasattr(self, 'memory_counter'): self.memory_counter = 0 transition = np.hstack((s, [a, r], s_)) index = self.memory_counter % self.memory_size self.memory[index, :] = transition # memory是一个二维列表 self.memory_counter += 1 接着是learning函数 1234567891011121314151617181920def learn(self): if self.learn_step_counter % self.replace_target_iter == 0: self.target_replace_op() print('\ntarget_params_replaced\n') if self.memory_counter &gt; self.memory_size: sample_index = np.random.choice(self.memory_size, size=self.batch_size) else: sample_index = np.random.choice(self.memory_counter, size=self.batch_size) batch_memory = self.memory[sample_index, :] q_next, q_eval = self.model1.predict(batch_memory[:, -self.n_features:]), self.model2.predict( batch_memory[:, :self.n_features]) q_target = q_eval.copy() batch_index = np.arange(self.batch_size, dtype=np.int32) eval_act_index = batch_memory[:, self.n_features].astype(int) reward = batch_memory[:, self.n_features + 1] q_target[batch_index, eval_act_index] = reward + self.gamma * np.max(q_next, axis=1) self.model2.fit(batch_memory[:, :self.n_features], q_target, epochs=10) self.epsilon = self.epsilon + self.epsilon_increment if self.epsilon &lt; self.epsilon_max else self.epsilon_max self.learn_step_counter += 1 其他部分和莫凡代码是一样的，就不贴出来了。 完整的网络部分代码和环境部分代码放在github上了：https://github.com/Jason33Wang/ReinforcementLearning_by_keras 注明：DQN.py和maze_env.py文件是直接fork莫凡的 下面也贴上原莫凡的tensorflow代码：https://github.com/MorvanZhou/Reinforcement-learning-with-tensorflow/tree/master/contents/5_Deep_Q_Network 用keras搭建的网络用来训练这个游戏时，收敛的并没有莫凡原代码收敛的好，之后在原基础上，把memory的size增加了一倍后才收敛的较好。 写完这篇文章后，发现没什么技术含量，不过自己的思路更加清晰了，大家仅供参考吧。希望自己经过以后的学习能写出更好，更有深度的文章吧！]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>reinforecementLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[imageDataGenerator]]></title>
    <url>%2F2018%2F09%2F02%2FimageDataGenerator%2F</url>
    <content type="text"><![CDATA[在深度学习中，我们在trian我们的模型时，往往在数据方面很难找到足够的数据。而在keras中，提供了imageDataGenerator iamgeDataGenerator是一个生成器类，可以将我们输入的原始数据自动经过平移、旋转等操作，生成无限的差异性图片。在这里有意思的是在官方文档中，是用的无限（infinite）这个形容词。 方法如下： 1、实例一个生成器 12345678910111213datagen = ImageDataGenerator( featurewise_center=True, featurewise_std_normalization=True, rotation_range=20, width_shift_range=0.2, height_shift_range=0.2, horizontal_flip=True) 2、.fit方法 该方法用来计算各种操作的统计信息。 在笔者看来是类似于生成随机数，我们要生成一个seed datagen.fit(x_train) 3、 .flow方法 该方法用来生成无限的图片 datagen.flow(x_train, y_train, batch_size=32) 4、接着就可以用生成的数据进行愉快的训练啦 对于这些实时产生的数据，我们可以调用fit_generator接口，实时的利用这些数据进行训练我们的模型 1fit_generator(self, generator, steps_per_epoch, epochs=1, verbose=1, callbacks=None, validation_data=None, validation_steps=None, class_weight=None, max_q_size=10, workers=1, pickle_safe=False, initial_epoch=0) 利用的Python的生成器，逐个生成数据的批次并进行训练。生成器与模型将并行执行以提高效率。例如，该函数允许我们在CPU上进行实时的数据提升，同时在GPU上进行模型训练 函数的参数是： 发电机：生成器函数，生成器的输出应该为： 一个形如（输入，目标）的元组 一个形如（inputs，targets，sample_weight）的元组。所有的返回值都应该包含相同数目的样本。生成器将无限在数据集上循环。每个epoch以经过模型的样本数达到samples_per_epoch时，记一个epoch结束 steps_per_epoch：整数，生成当器报道查看steps_per_epoch次数据时计一个历元结束，执行下一个历元 epochs：整数，数据迭代的轮数 verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个历元输出一行记录 validation_data：具有以下三种形式之一 生成验证集的生成器 一个形如（输入，目标）的元组 一个形如（输入，目标，sample_weights）的元组 validation_steps：当validation_data为生成器时，本参数指定验证集的生成器返回次数 class_weight：规定类别权重的字典，将类别映射为权重，常用于处理样本不均衡问题。 sample_weight：权值的numpy数组，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（样本，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了sample_weight_mode=’temporal’。 wokers：最大进程数 max_q_size：生成器队列的最大容量 pickle_safe：若为真，则使用基于进程的线程。由于该实现依赖多进程，不能传递non picklable（无法被pickle序列化）的参数到生成器中，因为无法轻易将它们传入子进程中。 initial_epoch：从该参数指定的epoch开始训练，在继续之前的训练时有用。 同样的，我们有evaluate_generator 1evaluate_generator(self, generator, steps, max_q_size=10, workers=1, pickle_safe=False) 本函数使用一个生成器作为数据源评估模型，器生成应报道查看与test_on_batch的输入侧数据相同类型的数据。函数该参数的与fit_generator同名参数含义相同，步骤是生成器要返回数据的轮数。 同样的，我们有predict_generator 1predict_generator(self, generator, steps, max_q_size=10, workers=1, pickle_safe=False, verbose=0) 本函数使用一个生成器作为数据源预测模型，器生成应报道查看与test_on_batch的输入侧数据相同类型的数据。函数该参数的与fit_generator同名参数含义相同，步骤是生成器要返回数据的轮数。 5、我们也有另外一种训练模型的方法： 12345678910111213141516171819for e in range(epochs):print('Epoch', e)batches = 0for x_batch, y_batch in datagen.flow(x_train, y_train, batch_size=32):loss = model.fit(x_batch, y_batch)batches += 1if batches &gt;= len(x_train) / 32:# we need to break the loop by hand because# the generator loops indefinitelybreak]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>keras</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苟有恒，何必三更睡五更起。最无益，莫过一日曝十日寒]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%AD%A3%E8%83%BD%E9%87%8F%2F</url>
    <content type="text"><![CDATA[#看到的好的句子就记下来激励自己]]></content>
      <categories>
        <category>警句</category>
      </categories>
      <tags>
        <tag>警句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql笔记]]></title>
    <url>%2F2018%2F09%2F02%2Fmysql%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[mysql学习笔记sql的分类 数据查询语言（dql ：data query language） 代表关键字：select 数据操作语言（dml：data manipulation language） 代表关键字：insert，delete，update 数据定义语言（ddl：data definition language） 代表关键字：create，drop，alter 事物控制语言（tcl：transactional control language） 代表关键字：commit，rollback 数据控制语言（dcl：data control language） 代表关键字：grant，revoke 123456789101112131415161718#创建数据库create database fliename；#选择数据库use database_name#查询当前数据库select database();#查询数据版本select version();#终止当前语句\c#退出mysql\q,QUIT，EXIT#显示命令show databasesshow tablesdesc tabele_name#查看怎么创建的某个表show create table 【name】 查询语句1234567891011121314151617181920212223242526#无所谓大小写select 【字段，字段，字段】 from 表#条件查询select 【 】 from 表 where 表达式找出工作岗位是manger和工作岗位是salesman的员工######################################select ename，jobfrom empwhere job= &apos;manger&apos; or job=&apos;salesman&apos;； 等同于select ename,jobfrom empwhere job in (&apos;manger&apos;,&apos;salesman&apos;)；######################################3like 用法： 其中%代表0～n个字符 _代表一个任意字符select ename from emp where ename like &apos;%o%&apos; 模糊查询################################################### 升序排列，降序排列1234select ename，sal from emp order by sal asc；#升序排列select ename，sal from emp order by sal desc；#降序排列 数据处理函数/单行处理函数 Lower 转换成小写 upper 转换成大写 substr 取子字符串（substr（被截取的字符串，起始下标，截取的长度）） length 去长度 trim 去空格 str_to_date 将字符串转换成日期 date_format 格式化日期 format 设置千分位 round 四舍五入 rand() 生成随机数 ifnull 可以将null转换成一个具体值 关于mysql中的日期处理 每一个数据库处理日期的时候，采用的机制是不同的，日期处理都有自己的一套机制。所以在实际的开发中，表中的字段定义为DATA类型，这种情况很少。因为一旦使用日期类型，那么java程序将不能够通用那么在实际开发中，一般会使用”日期字符串“来表示日期 日期是数据库本身的特色，也是数据库本身机制中的一个重要的内容，所以还是需要掌握 MYSQL数据库管理系统中对日期提供了两个重要的函数： -str_to_date -date_format str_to_date 该函数的作用是：将”日期字符串“转换成”日期类型“数据。【varchar—&gt;date】 该函数的执行结果是date类型 该函数的使用格式： ​ str_to_date(‘日期类型’,’日期格式’) 关于MYSQL中的日期格式： 回顾java中的日期格式： ​ yyyy 年 ​ MM 月 ​ dd 日 ​ HH 时 ​ mm 分 ​ ss 秒 ​ SSS 毫秒 java中将字符串转换成日期类型： ​ 12SimpleDateFormat sdf = new SimpleDateFormat（"yyyy-MM-dd"）Date date = sdf.parse("1970-10-10") MYSQL的日期格式： | %Y | 年 || :–: | —- || %m | 月 || %d | 日 || %H | 时 || %i | 分 || %s | 秒 | 案例：查询出1980-12-17入职的员工 1234567select ename from hirdate from emp where hirdate=&apos;1980-12-17&apos;#mysql默认的日期格式：%Y-%m-%d，以上的日期字符串&apos;1980-12-17&apos;正好和默认的日期格式一致，存在了自动类型转换，自动将日期字符串转换了日期类型，所以以上查询可以查询出结果。#如果写下面语句则会报错select ename from hirdate from emp where hirdate=&apos;12-17-1980&apos;#想要纠正错误可以改成以下语句select ename from hirdate from emp where hirdate=str_to_date(&apos;12-17-1980&apos;,&apos;%m-%d-%Y&apos;) date_format 该函数的作用是：将日期类型date转换成具有特定格式的日期字符串varchar 该函数的运算结果是：varchar类型【具备特定格式的】 该函数的语法的格式： ​ date_format(日期类型数据，’日期格式’) 多用于查询操作 分组函数/聚合函数/多行处理函数 count 取得记录数 sum 求和 avg 取平均 max 取最大的数 min 取最小的数 以上函数自动忽略空值，分组函数不能使用在where语句中 去除重复内容distinct只能放在记录最前面 12select distinct job from emp；select distinct deptno，job from emp；#将两个字段同时来看 分组查询 group by group by 【表示通过哪个或者哪些字段进行排序】 案例：找出每个工作岗位的最高薪水 1234567891011#先按照工作岗位分组，使用max函数求每一组的最大值select max(sal) from emp group by job#其中 emp group by job 是一个整体#表示先按照job分组，然后对每一组使用max（sal）求最高薪水#在这里有个坑select ename,job,max(sal) from emp group by job#在低版本的mysql中这个语句是可以执行的但是执行结果没有意义，这是由于语法在这方面比较松散，不严格。因为ename这个字段根本不是分组字段所以是不能放在select后面的。在其他数据库中比如oracle中时会报错的#重点：若一条DQL语句中有group by 子句，那么select关键字后面只能跟参与分组的字段和分组函数 having having和where功能相同都是为了完成数据的过滤 where和having后面都是添加条件 where在group by之前完成过滤 having在group 后面完成过滤 案例：找出每个工作岗位的平均薪水，要求显示平均薪水大于1500 1select job,avg(sal) from emp group by job having avg(sal)&gt;1500 原则： 尽量在where中过滤，无法过滤的数据，通常都是需要先分组之后再过滤的，这个时候可以选择使用having。 一个完整的DQL语句的总结： select ​ ××××× from ​ ××××× where ​ ××××× group ​ ××××× having ​ ××××× order by ​ ××××× 第一：以上的关键字顺序不能变，严格遵守 第二：执行顺序： ​ 1、from 从某张表中检查数据 ​ 2、where 经过某条件进行过滤 ​ 3、group 然后分组 ​ 4、having 分组之后不满意在过滤 ​ 5、select 查询出来 ​ 6、order by 排序输出 连接查询 连接查询，也可以叫跨表查询，需要关联多个表进行查询 链接查询根据出现的年代分类： sql92 sql99 链接查根据链接方式可以分为： 内连接 等值连接 非等值连接 自连接 外连接 左外连接 右外连接 全连接【不讲，使用很少】 当多张表进行连接查询，若没有任何条件限制，会发生什么现象？ 案例1：查询每个员工所在的部门名称，要求最终显示员工名和对应的部门名。 小知识点：在进行多表连接查询的时候，尽量给表起别名，这样效率高，可读性高。 1234select e.ename,d.dname from emp e,dept d;#如果不增加任何限制的话会出现笛卡尔积现象#注意：连接查询过程中虽然使用了限制条件，但是匹配的次数没有减少，还是相乘次数，只不过这一次显示的结果都是有效记录select e.ename,d.dname from emp e,dept d where e.xx = d.xx 案例2：找出每一个员工对应的工资等级，要求显示员工名，工资，工资等级 1234#sql99语法中的等值连接中的非等值连接select e.ename,e.sal,s.grade from emp e 【inner】 join salgrade s on e.sal between s.local ans s.hisal#sql92语法：select e.ename,e.sal,s.grade from emp e ， salgrade s where e.sal between s.local ans s.hisal 案例3：找出每一个员工的上级领导，要求显示员工名以及对应的领导名 123#同一张表，我们需要吧一张表看成两张表#sql99语法中内连接中的非等值连接select a.ename empname ,b.ename leadername from emp a 【inner】join emp b on a.mgr = b.empno; 案例4：找出每一个员工对应的部门名称，要求部门名称全部显示 12345678910#内连接：# a表和b表能够完全匹配的记录查询出来，就被称为内连接#外连接：# a表和b表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的 完全查询出来，对方表没有匹配的记录，会自动模拟出null与之匹配，这种 查询被称为外链接。 外连接查询的结果条数&gt;=内连接的查询结果条数#sql99语法：外连接中的右外连接【右连接】select e.ename,d.dname from emp e right 【outer】 join dept d on e.deptno = deptno; #outer可以省略#sql99语法：外连接中的左外连接【左连接】select e.ename,d.dname from dept d left 【outer】 join emp e on e.deptno = deptno; #outer可以省略#上面两种写法是相同的，任何一个右外连接都可以写成左外连接，反之同样成立 为什么inner和outer可以省略，加上去有什么好处？ 可以省略，因为区分内连接和外连接依靠的不是这些关键字，而是看sql 语句中是否存在right和left，若存在，表示一定是一个外连接，其他的都是内连接 加上去的好处是增强可读性 多张表进行表连接的语法格式： select xxx from a join ​ b on ​ 条件 join ​ c on ​ 条件； 原理： 子查询1、什么是子查询？ select语句嵌套select语句 2、子查询可以出现在哪而？ select…(select) from…(select) where..(select) 3、where后面添加select子查询 案例：找出薪水比公司平均薪水高的员工，要求显示员工名和薪水。 1234567select ename，sal from emp where sal &gt; avg(sal)#以上语句执行报错，分组函数不能直接使用在where后面#正确做法#第一步：找出公司的平均薪水#第二部：找出薪水大于平均薪水的员工信息select ename,sal from emp where sal &gt; (select avg(sal) from emp) 4、from后面使用子查询 案例：找出每个部门的平均薪水，并且要求显示平均薪水的薪水等级。 第一步：找出每个部门的平均薪水 1select deptno, avg(sal) as avgsal from emp group by deptno; 第二步：将上面的临时查询结果当做临时表t，t表进行表连接，条件：t.avg(sal) between s.local and s.hisal 12345678select t.deptno,t.avgsal,s.grade from (select deptno, avg(sal) as avgsal from emp group by deptno) tjoin salgrade s on t.avgsal between s.local and s.hisal; 5、在select后面使用子查询【了解】 1select e.ename,(select d.dname from dept d where e,deptno = d.deptno) as dname from emp e; unionunion可以合并集合（相加） 123456select ename,job from emp where job = &quot;manager&quot;unionselect ename,job from emp where job = &quot;salesman&quot;#等同于以下写法select ename,job from emp where job in [&quot;manager&quot;,&quot;salesman&quot;] limit limit用来获取一张表中的某部分数据 limit只有在mysql数据库中存在，不通用，是mysql数据库管理系统的特色 12345678#案例1：找出员工表中前5条记录select ename from emp limit 5；#以上的sql语句的“limit 5”中的5表示从表中记录下标0开始，取5条等同于下面的sql语句select ename from emp limit 0,5；#limit的使用语法格式：limit起始下标没有指定，默认从0开始，0表示表中第一条记录。#案例2：找出公司中工资排名在前5名的员工select ename,sal from emp order by sal desc limit 5; mysql中通用的分页sql语句： 1234567891011#每页显示3条记录每页显示3条记录第1页：0,3第2页：3,3第3页：6,3第4页：9,3.。。。。每页显示pagesize条记录第pageNo页：（pageNo-1）×pagesize，pageSizeselect ename,sal from emp order by sal desc limit （（pageNo-1）×pagesize，pageSize）; 表 创建表 表格（table），用来存储数据，表格是一种结构化文件。 表格行被称为记录（表中的数据），表格列被称为字段。 表格的字段属性包括：字段名称、字段数据类型、字段长度、字段约束 12345create table tableName（ columnName dataType(length), columnName dataType(length)）;set character_set_results=&apos;gbk&apos;; 关于mysql数据库中的数据类型？ varchar 可变长度字符串 空间效率高，时间效率低 char 定长字符串 时间效率高，但是空间效率不一定会高 int 整数型 int(3)表示最大可以存储999 bigint 长整形 对应的java程序中的lon类型 float 浮点型单精度 double 浮点型双精度 double（7,2）表示7个有效数字，2个小数位 date 日期类型 在实际来发中为了通用，所以日期类型一般不适用，采用字符串代替日期类型比较多 blob Binary Largre Object二进制大对象 专门存储图片声音视频等数据 数据库表中存储一个图片是很常见的，但是存储一个比较大的视频是很少见的，一般都是提供一个视频的链接地址 clob character Large Object字符大对象 可以存储比较大的文本，4G+的字符串可以存储 其他 insert 向表格插入数据必须是使用insert语句，这属于dml语句 dml语句包括：insert，update，delete、 insert语句的语法格式： insert into tablename （columnname1，columnname2，columnname3）values（value1，value2，value3） 字段和值必须一一对应，个数必须相同，数据类型必须一致。 关于sql脚本 该文件是一个普通的文本文件，后缀名.sql，被称为sql脚本 在sql脚本中有大量的sql语句，想批量的执行sql语句，可以将这些sql语句写入sql脚本文件中，直接使用source执行这个脚本，可以执行大量的sql语句 增删改表结构(不是很重要)（DDL）12345678#如需求改变，需要向t_studnts中加联系电话字段，字段名称为：contact_tel 类型为varchar（40）#增alter table t_student add contact_tel varchar(40)#将长度改为20#改alter table t_student modify tel varchar(20)#删alter table t_student drop tel 增删改表中的数据【insert、update、delete】update update语句的语法格式： update tablename set 字段名 = 字段值，字段名 = 字段值，where 条件； 注意：update语句没有条件，会将一张表中所有的数据全部更新 12345678#将no=3的记录name修改为zhangsan，email修改为zhangsan@bjpowernode.comupdate t_student set name=&apos;zhangsan&apos;,email =&apos;zhangsan@bjpowernode.com&apos; where no = 3;#将所有的name都修改为lisiupdate t_student set name = &apos;lisi&apos;;#将emp_bak中的所有的名字中含有o的员工名修改为zhangsanupdate emp_bak set ename = &apos;zhangsan&apos; where ename like &apos;%o%&apos;;#将emp_bak表中所有工作岗位是manager和salesman的员工工资上调10%update emp_bak set sal=sal*1.1 where job = &apos;manager&apos; or job = &apos;salesman&apos; delete delete 语句的语法格式： delete from tablename where 条件 注意：若没有条件限制，会将这种表中所有的记录全部删除 1234#删除学号=3的学生delete from t_student where no = 3#删除所有记录delete from t_student 约束 什么是约束，为什么要使用约束？ 约束对应的英语单词：constraint 约束实际上就是表中数据的限制条件 表在设计的时候加入约束的目的就是为了保证表中的记录完整和有效 约束包括哪些？ 非空约束 not null 唯一性约束 unique 主键约束 primary key 简称PK 外键约束 foreign key 简称FK 检查约束【目前mysql不支持，oracle支持】 非空约束 not null约束的字段，不能为NULL值，必须给定具体的数据 创建表，给字段添加非空约束【创建用户表，用户名不能为空】 12345create table t_user( id int(10), name varchar(32) not null not null, email varchar(128)); 唯一性约束 unique约束的字段具有唯一性，不可重复 123456789101112131415161718192021222324252627282930313233343536#创建用户，保证邮箱地址唯一#列级约束create table t_user( id int(10), name varchar(32) not null not null, email varchar(128) unique);#表级约束create table t_user( id int(10), name varchar(32) not null not null, email varchar(128) ， unique（email）);#注意，使用表级约束给多个字段联合添加约束【以下程序表示name和email两个字段联合唯一】create table t_user( id int(10), name varchar(32) not null not null, email varchar(128) ， unique（name,email）);#表级约束还可以给约束起名字#为什么要起名字，因为以后可以通过这个名字删除这个约束drop table if exist t_user;create table t_user( id int(10), name varchar(32) not null not null, email varchar(128) ， constraint t_user_email_unique unique（name,email）);#查询约束名字use information_schema;show tables;#其中有个表叫table_constraint的表专门用来存储约束信息的select constraint_name from table_constraints where table_name=&apos;t_user&apos;; 主键约束-primary key 简称PK 主键涉及到的术语： 主键约束 主键字段 主键值 以上的主键约束、主键字段、主键值的关系？ 表中的某个字段添加主键约束之后，该字段被称为主键字段，主键字段中出现的每一个数据都被称为主键值。 给某个字段添加主键约束primary key后，该字段不能重复，并且也不能为空。效果和not null unique相同，但是本质不同，主键约束除了可以做到not null unique之外，主键字段还会默认添加“索引-index” 一张表应该有主键字段，若没有，表示这张表是无效的。“主键值”是当前行数据的唯一标识。“主键值”是当前行数据的身份证号。即使表中的两行记录相关的数据是相同的，但是由于主键值不同，我们认为这是两行完全不同的数据。 给一个字段添加主键约束，被称为单一主键。 123456789101112131415#单一主键#列表定义方式 drop table if exist t_user; create table t_user( id int(10) primary key, name varchar(32) ) #单一主键 #列表定义方式 drop table if exist t_user; create table t_user( id int(10), name varchar(32)， primary key（id） ) 12345678910111213141516171819202122- - 给多个字段联合添加一个主键约束，被称为复合主键。- 无论是单一主键还是复合主键，一张表主键约束只能有一个- 主键根据性质分类： - 自然主键 - 主键值若是一个自然数，这个自然数和当前表的业务没有任何关系，这种主键叫做自然主键 。 - 业务主键 - 主键值若和当前表中业务紧密相关的，那么这种主键值被称为业务主键，当业务数据发生改变的时候，主键值通常会受到影响，所以业务主键使用较少。大部分都是使用自然主键。- 在mysql数据库管理系统中提供了一个自增的数字，专门用来自动生成主键值。主键值不需要用户维护，也不需要用户提供了，自动生成的。这个自增的数字默认从1开始，以1递增：1、 2、 3、 ....... - ```mysql drop table if exist t_uesr; create table t_user( id int(10) primary key auto_increment, name varchar(32) ) 外键约束 foreign key 简称FK 外键涉及到的术语 外键约束 外键字段 外键值 外键约束、外键字段、外键值之间的关系？ 某个字段添加外键约束之后，该字段称为外键字段，外键字段中的每一个数据都是外键值。 外键也分为：单一外键和复合外键（联合多个字段添加一个外键） 一张表中可以有多个外键字段。 分析场景： 请设计数据库用来存储学生和班级信息，给出两种解决方案： 学生信息和班级信息之间的关系，一个班级对应多个学生，这是典型的一对多的关系。 第一种设计方案：将学生信息和班级信息存储到一张表中。 学生信息表t_student sno(pk) sname classno cname 1 jack 100 实验中学1班 2 allen 200 实验中学2班 3 lucy 200 实验中学2班 4 lisi 300 实验中学3班 以上设计缺点：数据冗余 第二种解决方案：将学生信息和班级信息分开两张表存储你，学生表 + 班级表 学生表t_student sno(pk) sname classno（fk） 1 jack 100 2 allen 200 3 lucy 200 4 lisi 300 班级表t_class cno(pk) cname 100 实验中学1班 200 实验中学2班 300 实验中学3班 结论：为了保证t_student表中的classno字段中的数据必须来自于t_class表中cno字段中的数据，有必要给t_student表中的classno字段添加外键约束，classno字段被称为外键字段，该字段中的100、 200、 300、被称为外键值。classno这里是一个单一外键字段 注：外键值可以为null。 注：外键字段去引用一张表的某一个字段的时候，被引用的字段必须具有unique约束。 注：有了外键引用之后，表分为父表和子表，以上父表是：班级表，子表是：学生表。创建表先创建父表，在创建子表，删除数据的时候，先删除子表中的数据，后删除父表中的数据。插入数据的时候先插入父表中的数据，再插入子表中的数据 12345678910111213141516171819202122232425insert into t_student(sno,sname,classno) value(1,&apos;&apos;,100);insert into t_student(sno,sname,classno) value(1,&apos;&apos;,100);drop table if exists t_student;drop table if exists t_class;create table t_class( cno int(3) primary key, cname varchar(128) not null unique);create table t_students( sno int(3) primary key, sname varchar(32) not null, classno int(3), constraint t_student_classno_fk foreign key(classno) reference t_class(cno));insert into t_class(cno,cname) value(100,&apos;高三一班&apos;)；insert into t_class(cno,cname) value(200,&apos;高三二班&apos;)；insert into t_class(cno,cname) value(300,&apos;高三三班&apos;)；insert into t_student(sno,sname,classno) value(1,&apos;jack&apos;,100);insert into t_student(sno,sname,classno) value(2,&apos;tom&apos;,100);insert into t_student(sno,sname,classno) value(3,&apos;lucy&apos;,200);insert into t_student(sno,sname,classno) value(4,&apos;king&apos;,200);insert into t_student(sno,sname,classno) value(5,&apos;wang&apos;,300);insert into t_student(sno,sname,classno) value(6,&apos;lisi&apos;,300);select * from t_studengt;select * from t_class; 重点：典型的一对多的设计模式，在多的一方加外键。 级联更新和经联删除 添加级联更新和级联删除的时候需要在外键约束后面添加 在删除父表中的数据时，级联删除子表中的数据 on delete cascade 删除外键约束 alter table t_student drop foreign key fk_name; 添加外键约束 alter table t_student add constraint fk_name foreign key (classno) references t_class(cno) on delete cascade 在更新父表中的数据时，级联更新子表中的数据 on update cascade 删除外键约束 alter table t_student drop foreign key fk_name; 添加外键约束 alter table t_student add constraint fk_name foreign key (classno) references t_class(cno) on update cascade 以上的级联更新和级联删除谨慎使用，因为级联操作会将数据改变或者删除【数据无价】]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
